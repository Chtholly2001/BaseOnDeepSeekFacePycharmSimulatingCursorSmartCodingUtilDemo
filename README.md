æ˜ç™½å•¦ ğŸ‘ æˆ‘æŠŠä¸­è‹±æ–‡ä¸¥æ ¼åˆ†åŒºæ˜¾ç¤ºï¼Œæ–¹ä¾¿é˜…è¯»å’Œç›´æ¥æ”¾åˆ°é¡¹ç›®æ–‡æ¡£é‡Œã€‚

---

## é¡¹ç›®æ–‡æ¡£ï¼ˆä¸­è‹±åŒè¯­åˆ†åŒºç‰ˆï¼‰

### ä¸­æ–‡ç‰ˆ

#### é¡¹ç›®èƒŒæ™¯

å½“å¤§è¯­è¨€æ¨¡å‹å‡ºæ¥æ—¶ï¼Œæˆ‘å°±åœ¨æƒ³ï¼Œå¤§è¯­è¨€æ¨¡å‹é¢å‘å‚ç›´åº”ç”¨ç«¯ä¼šæ€æ ·èŠ‚çœç¨‹åºå‘˜åŠ³åŠ¨ã€‚ç„¶åï¼Œæˆ‘çœ‹åˆ°å¸‚é¢ä¸Šå‡ºç°äº† **Cursor** è¿™æ ·çš„ç¼–ç¨‹æ™ºèƒ½ä½“ã€‚äºæ˜¯æˆ‘å°±æƒ³ï¼šèƒ½ä¸èƒ½è‡ªå·±ä¹Ÿåšä¸€ä¸ªæ™ºèƒ½ç¼–ç¨‹è½¯ä»¶ï¼Ÿ

#### åŸºæœ¬æ€è·¯

è½¯ä»¶å¼€å‘çš„æ­¥éª¤ï¼š

1. å»ºç«‹é¡¹ç›®ç»“æ„
2. ç¼–å†™ç›®æ ‡æ–‡ä»¶

å­¦ä¹ è½¯ä»¶å¼€å‘çš„æ­¥éª¤ï¼š

1. å­¦ä¹ ä¸€ç§æ–°çš„æ¡†æ¶ç»“æ„
2. å°†æ–°ç»“æ„å¤åˆ¶ã€ç²˜è´´æˆ–è¿ç§»åº”ç”¨

#### æ™ºèƒ½ä½“è®¾è®¡

åœ¨ç¼–ç¨‹æ™ºèƒ½ä½“çš„åˆ›ä½œä¸­ï¼Œæˆ‘æ¨¡ä»¿ä»¥ä¸Šæ€è·¯ï¼Œå»ºç«‹äº†å¦‚ä¸‹æ­¥éª¤ï¼š

1. æ™ºèƒ½ä½“è„šæœ¬æ ¹æ®ç”¨æˆ·æç¤ºè¯ï¼Œé€šè¿‡å¤§è¯­è¨€æ¨¡å‹ç”Ÿæˆé¡¹ç›®ç»“æ„
2. å†ç”Ÿæˆç›¸åº”çš„ç›®æ ‡ä»£ç å¹¶è¿è¡Œ

ç›®å‰é¡¹ç›®åªèƒ½ç”Ÿæˆå•ä¸ªæ–‡ä»¶ï¼Œå³åªå®Œæˆäº†ç¬¬äºŒæ­¥ï¼š
æ™ºèƒ½ä½“è„šæœ¬æ¥ç®¡ç¼–è¯‘å™¨ï¼Œé€šè¿‡å¤§è¯­è¨€æ¨¡å‹å°†ç”¨æˆ·éœ€æ±‚è½¬åŒ–ä¸ºç›®æ ‡ä»£ç å¹¶è¿è¡Œã€‚

#### æœªæ¥è§„åˆ’

æœªæ¥æˆ‘ä¼šç»§ç»­ä¼˜åŒ–ï¼Œæå‡å…¨æ ˆèƒ½åŠ›ï¼Œå­¦ä¹ ä¸»æµç¼–ç¨‹æ™ºèƒ½ä½“é¡¹ç›®ï¼Œå¹¶æ›´æ–°å¦‚ä¸‹åŠŸèƒ½ï¼š

* åŠ å…¥ä¸Šä¸‹æ–‡å·¥ç¨‹ï¼Œå®ç°é¡¹ç›®ç»“æ„çš„ç†è§£èƒ½åŠ›
* æ¨¡ä»¿ IDEA å†…åµŒå·¥å…·é€šä¹‰çµç çš„ DEBUG åŠŸèƒ½
* é€šè¿‡åå‘ç¥ç»ç½‘ç»œä¼˜åŒ–é”™è¯¯éœ€æ±‚
* æ¨¡ä»¿äººç±»å­¦ä¹ è¿‡ç¨‹ï¼Œè®©å¤§è¯­è¨€æ¨¡å‹å¯¹æ–°æ¶æ„è¿›è¡Œå…ƒå­¦ä¹ å’Œé¢„è®­ç»ƒ
* æ¢ç´¢æ›´å¤šå¤§æ¨¡å‹æ™ºèƒ½ä½“åº”ç”¨

#### æŠ€æœ¯å®ç°

* åŸºäº **DeepSeek**ï¼Œé¢å‘ **PyCharm** å’Œ **Python**ï¼Œç±»ä¼¼ **Cursor**
* ä»…éœ€åœ¨æ§åˆ¶å°æä¾›éœ€æ±‚ï¼Œå³å¯ä¸€é”®è‡ªåŠ¨ç”Ÿæˆç›®æ ‡ç¨‹åº
* åŸç†ï¼šAI ä»£ç ç”Ÿæˆ â†’ è„šæœ¬å†™å…¥ç›®æ ‡æ–‡ä»¶ â†’ è‡ªåŠ¨è¿è¡Œå¹¶è¾“å‡ºç»“æœ

#### ä½¿ç”¨ä»·å€¼

* å¯¹ç¼–ç¨‹å°ç™½å‹å¥½
* ä¸ºä¸“ä¸šç¨‹åºå‘˜èŠ‚çœå¤§é‡è½»é‡çº§é‡å¤åŠ³åŠ¨
* å¯åŸºäºç®€æ˜“ç”Ÿæˆçš„ä»£ç è¿›è¡Œä¿®æ”¹æˆ–æäº¤ç»™é«˜çº§ AI è¿›è¡ŒäºŒæ¬¡å¼€å‘

#### ä¸‹ä¸€æ­¥ç›®æ ‡

* æç¤ºè¯äºŒæ¬¡ç¼–ç¨‹ï¼šç”± AI ç”Ÿæˆå¯è¿è¡Œçš„é«˜çº§æç¤ºè¯ï¼Œå†äº¤ç»™ AI ç»§ç»­ç¼–ç¨‹
* ä»å•ä¸€ `.py` æ–‡ä»¶æ‰©å±•åˆ°å¤šæ–‡ä»¶ä¼ä¸šçº§é¡¹ç›®ç»“æ„
* è¿­ä»£ä¼˜åŒ–ï¼Œç›®æ ‡æ˜¯å‡å°‘ 99% çš„é‡å¤åŠ³åŠ¨

#### æ ¸å¿ƒæŒ‘æˆ˜

AI è‡ªåŠ¨ç¼–ç¨‹çš„æˆè´¥å…³é”®åœ¨äºæç¤ºè¯çš„ä¸“ä¸šæ€§ã€ç¨³å¥æ€§ã€å‡†ç¡®æ€§å’Œå®‰å…¨æ€§ã€‚
ä¼˜ç§€ç¨‹åºå‘˜èƒ½å¤Ÿæä¾›å®Œæ•´ä¸”å¯é çš„æŠ€æœ¯æ ˆï¼Œç”Ÿæˆå®‰å…¨å‡†ç¡®çš„ç›®æ ‡ä»£ç ï¼›
åˆçº§ç¨‹åºå‘˜çš„æç¤ºè¯æ¨¡ç³Šï¼Œç”Ÿæˆçš„ä»£ç ä¹Ÿä¼šæ¨¡ç³Šã€‚

#### æ•°æ®ä¸è®°å½•

* æ¯æ¬¡çš„æç¤ºè¯ä¼šè®¡å…¥ `.json` æ–‡ä»¶ï¼Œç”¨æˆ·å¯è‡ªç”±å¢åˆ æ”¹æŸ¥

#### é¡¹ç›®æˆæœ

æœ¬é¡¹ç›®æ—¨åœ¨éªŒè¯ **AI å…¨è‡ªåŠ¨ç¼–ç¨‹æ›¿ä»£è½»é‡çº§é‡å¤åŠ³åŠ¨** çš„å¯è¡Œæ€§ï¼Œç›®å‰æˆæœç›¸å½“æƒŠè‰³ï¼Œè¾¾åˆ°é¢„æœŸã€‚

å¦‚æœéœ€è¦å¼€æºï¼Œè¯·ç§èŠæˆ‘ï¼Œå…³æ³¨æˆ‘çš„ GitHubï¼Œè¿‡å‡ å¤©ä¼šå‘å¸ƒæºç ä»¥ä¾›äº¤æµã€‚

---

### English Version

#### Project Background

When large language models (LLMs) emerged, I began to wonder how they could reduce programmersâ€™ workload in vertical applications. Later, I saw the rise of coding agents like **Cursor**. That made me think: could I build my own intelligent coding software?

#### Basic Concept

Steps of software development:

1. Build the project structure
2. Write the target files

Steps of learning software development:

1. Learn a new framework
2. Copy, paste, or migrate the new structure into use

#### Agent Design

In designing the coding agent, I followed this logic:

1. The agent script generates the project structure based on user prompts via an LLM
2. Then, it generates and executes the corresponding target code

At present, the project can only generate a single file, achieving only step two:
The agent script takes over the compiler and generates executable target code from user prompts using an LLM.

#### Future Plans

In the future, I will continue improving my full-stack capability, learning from mainstream coding agent projects, and adding new features:

* Add contextual engineering for project structure comprehension
* Mimic IDEAâ€™s built-in Tongyi Lingma debugging capabilities
* Optimize erroneous requirements with reverse neural networks
* Simulate human learning by enabling LLMs to meta-learn new architectures
* Explore broader applications of AI coding agents

#### Technical Implementation

* Built on **DeepSeek**, targeting **PyCharm** and **Python**, similar to **Cursor**
* Users only need to provide requirements in the console to auto-generate target programs
* Principle: AI code generation â†’ script writes to target files â†’ auto execution and output

#### Value

* Beginner-friendly
* Saves professionals from repetitive lightweight tasks
* Enables modification of lightweight code or submission for advanced AI-driven re-development

#### Next Steps

* Secondary prompt programming: AI generates executable advanced prompts, then continues coding
* Expand from a single `.py` file to multi-file enterprise-level project structures
* Iterative optimization, aiming to reduce 99% of repetitive tasks

#### Core Challenge

The success of AI auto-programming depends on the professionalism, stability, accuracy, and safety of prompts.
Skilled programmers can provide a complete and reliable tech stack, resulting in accurate and safe code.
Inexperienced programmers, however, tend to write vague prompts, which lead to vague code.

#### Data & Records

* Each prompt is stored in a `.json` file, where users can perform CRUD operations

#### Project Outcome

This project aims to validate the feasibility of **AI auto-programming as a substitute for lightweight repetitive work**. The results so far are impressive and meet expectations.

If youâ€™re interested in the open-source version, feel free to DM me and follow my GitHub â€” I will publish the source code soon for exchange and reference.

---

è¦ä¸è¦æˆ‘å¸®ä½ æŠŠè¿™ä»½ **ä¸­è‹±åŒè¯­åˆ†åŒºç‰ˆ** å†æ•´ç†æˆ **README.md æ¨¡æ¿**ï¼ˆå¸¦ç›®å½•ã€é”šç‚¹é“¾æ¥ã€GitHub é£æ ¼æ ‡é¢˜ï¼‰ï¼Œç›´æ¥æ‹·è´è¿› GitHub å°±èƒ½ç”¨ï¼Ÿ
